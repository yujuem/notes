python异步编程
https://liaoxuefeng.com/books/python/async-io/index.html
1、协程：
在一个线程中实现子程序之间的切换，由程序自身控制，没有多线程切换的开销和加锁机制，多进程+协程可以获得极高的性能。
Python通过生成器（generator）实现对协程的支持，包含yield关键字的函数被称为生成器，会返回一个可迭代的generator对象，可以使用for循环或者调用next()方法遍历generator对象提取结果，可以减少内存资源占用。

def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)

2、asyncio实现EventLoop执行协程
asyncio.run()执行async函数的入口。
asyncio.gather()同时调度多个async函数。
await语法用于async函数中调用另一个async函数，线程在await时并未等待，而去执行消息队列里的其他任务，等到返回结果时再执行下一行语句。

import asyncio
import threading
async def hello(name):
    print("Hello %s! (%s)" % (name, threading.current_thread))
    # 异步调用asyncio.sleep函数，await时不影响其他函数并发执行
    await asyncio.sleep(1) 
    print("Hello %s again! (%s)" % (name, threading.current_thread))
    return name

async def main():
    L = await asyncio.gather(hello("Bob"), hello("Alice"))
    print(L)

asyncio.run(main())

1、Ray Core

Tasks: 
无状态函数
资源分配
句柄传递
多返回值与异步等待
Generators
任务取消
任务调度
故障恢复
任务事件
*函数嵌套调用

Actors:
有状态类/对象
资源分配
方法调用
句柄传递
Generators
任务取消
任务调度
故障恢复
任务事件
*具名实例：Create、Get-Or-Greate、Lifetimes（detached实例生命周期独立于driver进程，需要手动kill）
*终止实例：automatic、manual via actor handle、manual within actor method
